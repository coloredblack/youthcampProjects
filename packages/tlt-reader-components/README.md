# TLT-Reader-Components

作为第三天的作业，想要用自己学习的组件体系知识，给自己的TLT项目写一套组件体系。

## 分析

### 分析功能需求

TLT项目前端Reader层的展示交互需求有：

- 页面：一个主要界面，可以支持嵌套子界面，让读者可以同时阅读多个文件，子界面可以分割，方便的来回切换和翻页。
- 文字展示：主要负责展示不同长短大小的文字。作为一个阅读器，此类组件的要求比一般的组件库要复杂细致。
- 链接：对于阅读中遇到的特定语句，需要有方便的链接，预览，跳转等功能。这一类组件的特点是存在背后的逻辑相关性，对于关系全局的把握要求较高。但同时要求不能喧宾夺主。
- 图：对于复杂的长文本，用图可视化的方法表现复杂的文章结构是一种必不可少的手段，如今常见基于markdown双向链接构成的文本图可视化依然不够方便。此外，图放大，切分，不同粒度概述缩放也是必要的，甚至图组件本身应该可以和其他组件动态绑定。这些要求对常见的组件提出了很高的挑战。
- 交互：主要在于从读者方面获得信息。需要考察读者进行阅读和写作时候的不同需求，在阅读时候，需要尽可能排除一切复杂的交互和干扰，而在写作，笔记的时候，则需要更细致地获得信息，并随时跳转记录，与其他文本进行链接。

### 可访问性

听书功能切换。正常读者也有听书的需求，所以正常的交互组件需要有切换到听书模式的需求。

### 信息结构和实现分离

由于前面已经提出了阅读模式和写作模式的不同，我有个想法，能不能把组件的“信息结构”和组件的“交互”分离。

“信息结构”主要展现了组件的信息模型，包括展示信息状态，接受参数范围和对应参数引发的信息状态变化。至于如何接受这些参数，能否把一些基础的信息结构组合成为复杂的整体组件，则是下一步具体实现。

“交互”主要展现了这些信息结构和参数的实现和封装。举个例子，多选框，对于视力正常者来说是一种多个选择项的封装，而对于视觉残疾人来说是依次询问并确认回复。

举个例子：

对于一个正在进行某本书阅读的界面来说，当前需要提供的信息有：

- 文本的内容
- 必要的命令接口

读者可能希望的指令有：

切换页面信息（翻到下一页最为常见）
某个感兴趣的词是什么意思？
这里不太懂，先跳过，后面回来看
哎呀有事情，暂时停一停。
这儿有个错别字，想改过来。
这个句子好，有没有完整？想要摘抄下来。

这些需求依然很复杂，我们可以继续拆分，读者可能会对：

该界面的外延感兴趣：其他页面，下一页，暂停跳转
该界面的内涵感兴趣：某个句子，段落，人名，地名
对该界面进行某些标记：书签，收藏等

对于阅读器来说，接收到明确指令之前需要有清晰确认指令的功能。读者选中了一段文字，究竟是想要搜索？标记？复制？还是编辑？

在写作的界面中，参考，补充，封装的需求是非常强烈的。

- 参考：有索引，具体细节不知道，确认一下就回来
- 封装：前面这一段比较完备了，我不想在上面消耗更多心神，希望着重于当前
- 补充：更丰富的索引。

对于三种需求，完全可以把用户的模型体验建立为某种流机构，对于写作来说就是历史记录，对于阅读来说就是前后页面，对于听书来说就是正在听的内容前后语境。

### 国际化

暂时只关注中文网文，不用过多考虑国际化的事情。

## 组件库设计

### 基类Role

### 管理组件Manager

控制组件使用资源的相关组件（控制组件的组件），将数据出入口，用户交互层等看做“资源”，更高效合理地根据优先级分配给不同的组件。比如排版，更换工具箱选项，更换操作顺序等都是Manager组件的工作职责。

### 控制组件Widgets

具有state值，update(feedbackCallbacks), sense(interestedStates, executeControllers), control(executeControllers, willExecutes), execute(upperstate, feedbacks), feedback(realExectes, feedbackCallbacks)

一个键值对，state指向当前的状态和渲染该状态的方法，sensor层以controller和state为输入，输出一个需要调用的controllers函数组进行调用,controllers注册状态对和函数， controller的合法函数输入一个状态集合，可以进行判断, 并返回某个状态改变方法callback(executor)。

contoller层执行sensor层

判断用户不同的“有效意愿”方法（指程序可以提供服务的意愿）对应的可能状态跳转方法。

如果每个状态对应的方法不为null则该组件是能观的，如果每个有效意愿的收集方法不为null，说明当前组件是能控的，如果一个途径是通畅的。

其实渲染该状态的方法完全可以用controller来注册写。无非是把最后的输出和交互看成一个巨大的Canvas组件。其state是一个输出的渲染矩阵和用户的鼠标，键盘操作等。

### 资源组件Resources

其实是对底层资源方法的封装，用于听从Manager的指令分配给相应的Widgets, 比如渲染屏幕的某一块区域，某些数据资源的通道，键盘鼠标等实践的监听通道等，都是资源组件。
